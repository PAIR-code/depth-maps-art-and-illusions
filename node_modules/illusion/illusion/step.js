var events = require('events');
var util = require('util');

function Step(name) {
    var self = this;
    this.name = name;
    this.status = 'idle';
    this.prevSteps = [];
    this.nextSteps = [];
}

util.inherits(Step, events.EventEmitter);

Step.prototype.connect = function(step) {
    var i = this.prevSteps.indexOf(step);
    if (i === -1) {
        step.nextSteps.push(this);
        this.prevSteps.push(step);
    }
};

Step.prototype.disconnect = function(step) {
    var i = this.prevSteps.indexOf(step);
    if (i !== -1) {
        step.nextSteps.splice(i, 1);
        this.prevSteps.splice(i, 1);
    }
};

Step.prototype.run = function(next) {
    if (this.action) {
        this.startAction(next);
    } else if (this.condition) {
        this.testCondition(next);
    } else {
        return next && next(new Error('Nothing can run'));
    }
};

Step.prototype.reset = function(next) {
    if (this.status === 'idle') {
        this.emit('idle');
        return next && next();
    }
    if (!this.cleanup) {
        this.status = 'idle';
        this.emit('idle');
        return next && next();
    }
    var self = this;
    this.cleanup(function() {
        self.status = 'idle';
        self.emit('idle');
        return next && next();
    });
};

Step.prototype.startAction = function(next) {
    var self = this;
    this.status = 'running';
    var startTime = Date.now();
    var timer;
    var callback = function() {
        if (timer) {
            clearTimeout(timer);
        }
        var delta = Date.now() - startTime;
        self.emit('runs', delta);
        if (arguments[0]) {
            self.status = 'failed';
            self.emit('failed', arguments[0]);
        } else {
            self.status = 'success';
            var args = Array.prototype.slice.call(arguments);
            self.emit.apply(self, ['success'].concat(args.slice(1)));
        }
        return next && next.apply(self, arguments);
    };
    if (this.timeout > 0) {
        timer = setTimeout(function() {
            callback = undefined;
            self.status = 'timeout';
            self.emit('timeout');
            return next && next(new Error('Timeout'));
        }, this.timeout);
    }
    this.action(function() {
        return callback && callback.apply(this, arguments);
    });
};

Step.prototype.testCondition = function(next) {
    var self = this;
    this.status = 'running';
    var startTime = Date.now();
    var timer;
    var callback = function() {
        clearInterval(timer);
        var delta = Date.now() - startTime;
        self.emit('waits', delta);
        if (arguments[0]) {
            self.status = 'failed';
            self.emit('failed', arguments[0]);
        } else {
            self.status = 'success';
            var args = Array.prototype.slice.call(arguments);
            self.emit.apply(self, ['success'].concat(args.slice(1)));
        }
        return next && next.apply(self, arguments);
    };
    timer = setInterval(function() {
        var delta = Date.now() - startTime;
        if (delta > self.timeout) {
            clearInterval(timer);
            callback = undefined;
            self.status = 'timeout';
            self.emit('timeout');
            return next && next(new Error('Timeout'));
        }
        self.condition(function() {
            return callback && callback.apply(self, arguments);
        });
    }, this.retryInterval);
};

Step.prototype.toBeEqual = function(result) {
    var self = this;
    var action = this.action;
    this.action = function(next) {
        action(function() {
            if (arguments[0]) {
                return next && next(arguments[0]);
            }
            if (!Array.isArray(result)) {
                result = [ result ];
            }
            if (arguments.length - 1 !== result.length) {
                return next && next(new Error('Result not as expect: ' + JSON.stringify(arguments)));
            }
            for (var i = 0; i < result.length; i++) {
                if (arguments[i+1] != result[i]) {
                    return next && next(new Error('Result not as expect: ' + JSON.stringify(arguments)));
                }
            }
            return next && next.apply(self, arguments);
        });
    };
    return this;
};

module.exports = Step;